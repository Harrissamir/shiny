% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R, R/shinywrappers.R
\name{exprToFunction}
\alias{exprToFunction}
\alias{createRenderFunction}
\title{Implement custom render functions}
\usage{
exprToFunction(
  expr,
  env = parent.frame(),
  quoted = FALSE,
  label = deparse(sys.call(-1)[[1]]),
  ..stacktraceon = FALSE
)

createRenderFunction(
  func,
  transform = function(value, session, name, ...) value,
  outputFunc = NULL,
  outputArgs = NULL,
  cacheHint = "auto",
  cacheWriteHook = NULL,
  cacheReadHook = NULL
)
}
\arguments{
\item{expr}{A user-supplied reactive expression (or quosure).}

\item{env}{The desired evaluation environment for the function.}

\item{quoted}{Is \code{expr} quoted?}

\item{label}{A label for the object to be shown in the debugger. Defaults to
the name of the calling function.}

\item{..stacktraceon}{Advanced use only. For stack manipulation purposes; see
\code{\link[=stacktrace]{stacktrace()}}.}

\item{func}{A function (with no parameters) which wraps a user's reactive
expression (i.e., the result of \code{exprToFunction()}). If the returned value
is a promise, then the render function will proceed in async mode.}

\item{transform}{A function that takes four arguments: \code{value},
\code{session}, \code{name}, and \code{...} (for future-proofing). This
function will be invoked each time a value is returned from \code{func},
and is responsible for changing the value into a JSON-ready value to be
JSON-encoded and sent to the browser.}

\item{outputFunc}{The UI function that is used (or most commonly used) with
this render function. This can be used in R Markdown documents to create
complete output widgets out of just the render function.}

\item{outputArgs}{A list of arguments to pass to the \code{uiFunc}. Render
functions should include \code{outputArgs = list()} in their own parameter list,
and pass through the value to \code{markRenderFunction}, to allow app authors to
customize outputs. (Currently, this is only supported for dynamically
generated UIs, such as those created by Shiny code snippets embedded in R
Markdown documents).}

\item{cacheHint}{One of \code{"auto"}, \code{FALSE}, or some other information to
identify this instance for caching using \code{\link[=bindCache]{bindCache()}}. If \code{"auto"}, it
will try to automatically infer caching information. If \code{FALSE}, do not
allow caching for the object. Some render functions (such as \link{renderPlot})
contain internal state that makes them unsuitable for caching.}

\item{cacheWriteHook}{Used if the render function is passed to \code{bindCache()}.
This is an optional callback function to invoke before saving the value
from the render function to the cache. This function must accept one
argument, the value returned from \code{renderFunc}, and should return the value
to store in the cache.}

\item{cacheReadHook}{Used if the render function is passed to \code{bindCache()}.
This is an optional callback function to invoke after reading a value from
the cache (if there is a cache hit). The function will be passed one
argument, the value retrieved from the cache. This can be useful when some
side effect needs to occur for a render function to behave correctly. For
example, some render functions call \code{\link[=createWebDependency]{createWebDependency()}} so that Shiny
is able to serve JS and CSS resources.}
}
\description{
Functions for implementing custom \code{renderXXX()} functions. In most cases,
these functions won't need to be used directly since most custom rendering
functions nowadays can \href{http://www.htmlwidgets.org/develop_intro.html}{simply wrap a call to \code{htmlwidgets::shinyRenderWidget()}}.
That said, custom \code{renderXXX()} functions that either: (1) don't want to use
htmlwidgets and/or (2) want to compute on the user-supplied reactive
expression should use of these functions for their implementation.
}
\section{Functions}{
\itemize{
\item \code{exprToFunction}: Convert a user expression into a debug-able
function that can then be passed to \code{\link[=createRenderFunction]{createRenderFunction()}}. This function
is designed to be called directly inside the 'top-level' \code{environment()} of
a custom render function (see the examples below).
}}

\examples{
# A basic custom render function
renderTriple <- function(x) {
  func <- exprToFunction(x)
  createRenderFunction(
    func,
    transform = function(value, session, name, ...) {
      paste(rep(value, 3), collapse=", ")
    },
    outputFunc = textOutput
  )
}

# Test render function from the console
a <- 1
r <- renderTriple({ a + 1 })
a <- 2
r()
}
